Sessions forUNIX and Shell ProgrammingA TextbookBehrouz A. Forouzan and Richard F. GilbergBrooks/Cole Publishing( ISBN 0 534-95159-7)COPYRIGHT (c) 2003 the Wadsworth Group. Brooks/Cole is an imprint of the Wadsworth Group, a division of Thomson Learning, Inc. Thomson Learning(tm) is a trademark used herein under license.============================================================Chapter 15 ------------------------------------------------------------Session 15.1 Examples of Stripping Strings $ x=Hello$ print ${x#???}            # Strip three characters from beginninglo$ print ${x%???}            # Strip three characters from endHe$ path=/bin/usr/staff/file$ print ${path##*/}         # Greedy strip from beginningfile$ print ${path%/*}          # Strip from end/bin/usr/staff$ eName=forouzan@fhda.edu$ print ${eName%@*}         # Strip from endforouzan------------------------------------------------------------Session 15.2 Demonstrate Profile File Command $ strcmp hello hello$ print $?0$ strcmp hello "so long"$ print $?1$ strcmp hello bye$ print $?2------------------------------------------------------------Session 15.3 Create Months Array $ set -A months Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec$ print ${months[1]}Feb------------------------------------------------------------Session 15.4 Create Months Array Revisited $ set -A months 0 Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec$ print ${months[1]}Jan------------------------------------------------------------Session 15.5 Create Months Array Revisited Again $ set -A month 0 Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec$ index=5$ print ${months[$index]}May------------------------------------------------------------Script 15.1 Substitute If Variable Null #!/bin/ksh#  Script: condValid.scr#  Demonstrate Substitute If Variable Null(-)print "Enter area code: \c"read  areaCodeareaCode=${areaCode:-(408)}print Area code is: $areaCode#  Rest of script follows$ condValid.scrExecutionEnter area code:Area code is: (408)------------------------------------------------------------Script 15.2 Substitute If Variable Not Null #!/bin/ksh#  Script: condNull.scr#  Demonstrate Substitute If Variable Not Null#  $1 is directory to be removeddir=$(ls $1)print ${dir:+"Directory $1 not empty. Can't delete it"}if [[ -z "$dir" ]] then   rmdir $1   print $1 was removedfiExecution:$ ls cond*                         # Verify directory statuscondNull.scr   condValid.scrcondDirNull:                       # Directory is not emptyfile1$ condNull.scr condDirNullDirectory condDirNull not empty. Can't delete it$ rm ./condDirNull/file1           # Delete only file$ ls cond*condNull.scr   condValid.scrcondDirNull:                       # Directory now empty$ condNull.scr condDirNullcondDirNull was removed------------------------------------------------------------Script 15.3 Demonstrate Substitution Assignment #!/bin/ksh#  Script: subAsgnmt.scr#  Demonstrate Substitution Assignmentprint "count contains: $count\n"while (( ${count:=1} < 10 ))do   print  "$count \c"   (( count = count + 1 ))     doneprint "\n"$ subAsgnmt.scrOutput:count contains:1 2 3 4 5 6 7 8 9------------------------------------------------------------Script 15.4 Substitution Validation #!/bin/ksh#  Script: subValid.scr#  This script verifies that the user entered a valueprint "Enter a value \c"read valtest=${val:?"You did not enter a value: Script terminates"}print "Script continues"Execution:$ subValid.scrEnter a valuesubValid.scr[7]: val:  You did not enter a value: Script terminates$ subValid.scrEnter value 1Script continues------------------------------------------------------------Script 15.5 Compress String Argument#!/bin/ksh #  Script: strDltSpaces.scr#  This script used print to delete extra spaces in a string.#  $1 is text stringline=$1print $line$ strDltSpaces.scr "Too   many   spaces     here."Output:Too many spaces here.------------------------------------------------------------Script 15.6 Compress File #!/bin/ksh #  Script: strComprFile.scr#  Compress all lines in a file#  $1 is file IDcat $1 | while read line         do             print $line         done$ strComprFile.scr spacy.dat$ cat spacy.datToo    many      spaces in   this text.Way  too     many spaces.Our  compress        script will    delete the extra spaces.Output:Too many spaces in this text.Way too many spaces.Our compress script will delete the extra spaces.------------------------------------------------------------Script 15.7 String Length #!/bin/ksh # Returns length of a string print "Enter a string: \c"read strInstrlen=${#strIn}print The string length is: $strlen$ strlen.scrOutput:Enter a string: Now is the timeThe string length is: 15------------------------------------------------------------Script 15.8 Use egrep to Find a Substring #!/bin/ksh #  Script: strinstrGrep.scr#  Determine if substring is in a string using grep #  $1 is string; $2 is a substringif (( $# != 2 ))then   print Two parameters are required.   print Usage: strinstrGrep.scr string substring   exit 2fiif print $1 | egrep "$2" > /dev/null/then   print \"$2\" found in \"$1\"else   print \"$2\" not in \"$1\"fi$ strinstrGrep.scr "Now is the time" "Now""Now" found in "Now is the time"$ strinstrGrep.scr "The time is now" "is""is" found in "The time is now"$ strinstrGrep.scr "The time is now" "it""it" not in "The time is now"$ strinstrGrep.scr "The time is now"Two parameters are required.Usage: strinstrGrep.scr string substring------------------------------------------------------------Script 15.9 Extract Hour and Minutes from date #!/bin/ksh #  Script: substr.scr#  Extracts hh:mm from system date.str=$(date)print The date is $strsubstr=$("$str" : '...........\(.....\).*')print The time is \"$substr\"$ substr.scrOutput:The date is Mon Jul 10 11:08:54 PDT 2000The time is "11:08"------------------------------------------------------------Script 15.10 Using Text in the Script #!/bin/ksh#  Script: hereDoc.scr#  This script uses a message contained in the document itself#  To send a meeting notice to all project members.list=$(cat hereDocTeam.mail) for i in $listdo   mail $i << MSG     The next project meeting is scheduled for next Friday.     LOCATION: Conf Room 12     TIME:     9am     AGENDA:   Please be prepared to discuss project schedule.               We have been asked to complete 3 months early.     AnneMSGdone$ funHereDoc.scr------------------------------------------------------------Script 15.11 Function Formatfunction_name ( )      # Name the function{                      # Opening brace is required statement statement . . . statement return value          # value is optional}                      # Closing brace is required------------------------------------------------------------Script 15.12 Script with a Simple Function #!/bin/ksh#  Script: funList.scr#  This script demonstrates the script concept# List Functionlist( ){ ls -l $1 | more}# Script Body# Call List Three Timeslist file1list file2list$ funList.scrOutput:-rw-r--r--    1 gilberg  staff        100 Jan 21 15:20 file1-rw-r--r--    1 gilberg  staff        100 Jan 21 10:39 file2total 154-rwxr--r--    1 gilberg  staff        111 Jan 20 09:47 IFS.scr-rw-r--r--    1 gilberg  staff       1425 Jan 25 17:50 MidRaven.bak ...-rwxr--r--    1 gilberg  staff         36 Jan 20 09:47 who.scr.bak-rwxr--r--    1 gilberg  staff         36 Jan 20 09:47 who.scrBak------------------------------------------------------------Script 15.13 Script with a Validate Function #!/bin/ksh#  Script: funValid.scr#  This script contains a function to validate numeric arguments.# Valid Functionvalid( ){#  Test parameter 1 by adding. All output to trash let x=$1+1 >/dev/null 2>&1 if (( $? != 0 ))              # if exit status is false then    print "$1 is not numeric"    exit 1                     # exit command kills script fi return}#  Script Body valid $1 valid $2Execution:$ funValid.scr 23 44$ funValid.scr 23 bb is not numeric$ funValid.scr a ba is not numeric------------------------------------------------------------Script 15.14 A Function That Returns a Value #!/bin/ksh#  Script: funAdd.scr#  This script contains a function that adds two arguments.# Add Functionadd( ){ # Add parameters $1 and $2 (( res = $1 + $2 )) return $res}# Script Body add 4 5 print " 4 +  5 is" $? add 42 96 print "42 + 96 is" $?# End script$ funAdd.scrOutput: 4 +  5 is 9 42 + 96 is 138------------------------------------------------------------Script 15.15 Compare Strings Function#!/bin/ksh#  Script: funStrCmp.scr#  Function to compare two strings#    Returns 0 if $1 = $2#            1 if $1 < $2#            2 if $1 > $2strcmp( ){   if [[ $1 = $2 ]]   then      res=0   else     ( print "$1" ; print "$2" ) > temp   # creating a two-line file      smaller=$(sort temp | head -1)      # sort and store smaller      if [[ $smaller = "$1" ]]      then           res=1      else           res=2      fi   # if smaller   fi      # if equal   return $res}  # End of strcmp function# Script Body   strcmp $1 $2   res=$?                                # Save compare result   if (( $res == 0 ))     then        print "$1 = $2"   else     if (( $res == 1 ))        then            print "$1 < $2 :"        else            print "$1 > $2 :"     fi  # $? == 1   fi # strcmpExecution:$ funStrCmp.scr Hello HelloHello = Hello$ funStrCmp.scr Hello ByeHello > Bye$ funStrCmp.scr Hello "So Long"Hello < So Long------------------------------------------------------------Script 15.16 Demonstrate Function File #!/bin/ksh#  funTest.scr#  Test Function Library--fun_strcmp    . functions.scr                       # Activate Function Library   fun_strcmp $1 $2   res=$?                                # Save compare result   if (( $res == 0 ))      then         print "$1 = $2"   else      if (( $res == 1 ))         then             print "$1 < $2"         else             print "$1 > $2"      fi # $? == 1   fi # strcmpExecution:$ funTest.scr hello hellohello = hello$ funTest.scr hello "so long"hello < so long$ funTest.scr hello byehello > bye------------------------------------------------------------Script 15.17 Demonstrate Signal Traps#!/bin/ksh#  Script: signal.scr#  Demonstrate use of signal traps(( i = 1 ))while (( $i < 1000 ))do   print $i   trap "" 24                               # Ignore trap 24   trap "print Cancelled by user.; exit 3" 2   (( i = i + 1 ))done$ signal.scrOutput:123...                           # Lines 4...92 manually deleted9394Cancelled by user.------------------------------------------------------------Script 15.18 Demonstrate sleep Command#!/bin/ksh#  Script: sleep.scr#  Monitors who is logged in and sends call me message#  Check every minute to see if $1 is logged inuntil who | grep "$1" >/dev/null   do      sleep 60   done                             # Run in background#  User is now logged inwrite $1 << MSG   Urgent we talk.   Please call me A.S.A.P!   GilbergMSG$ sleep.scr forouzan&------------------------------------------------------------Script 15.19 Demonstrate String Parameters #!/bin/ksh -f#  Script: strArguments.scr#  Demonstrate how string argument format affects readprint All Arguments: $*print Parm1 is: $1print Parm2 is: $2print Parm3 is: $3print Parm4 is: $4Execution:$ strArguments.str Now is the timeAll Arguments: Now is the timeParm1 is: NowParm2 is: isParm3 is: theParm4 is: time$ strArguments.str "Now is the time"All Arguments: Now is the timeParm1 is: Now is the timeParm2 is:Parm3 is:Parm4 is:------------------------------------------------------------Script 15.20 Prompt Script#!/bin/ksh #  Script: prompt.scr#  Demonstrate a typical user promptprint "Enter file name: \c"read fileNameprint You entered $fileName$ prompt.scrOutput:Enter file name: payroll.datYou entered payroll.dat------------------------------------------------------------Script 15.21 Question Script #!/bin/ksh #  Script question.scr#  Demonstrate question promptcontFlag=2while (( contFlag == 2 ))do   print "Do you want to continue [y/n]: \c"   read answer   case $answer in      y|Y) contFlag=1;;      n|N) contFlag=0;;        *) print Invalid response.            print Usage: \'y\' or \'n\'.   esacdoneif (( contFlag == 1 ))then   print script Continueselse   print script will stop; exit 1fi#  rest of script hereExecution:$ question.scrDo you want to continue [y/n]: zInvalid response.Usage: 'y' or 'n'.Do you want to continue [y/n]: yscript Continues$ question.scrDo you want to continue [y/n]: Nscript will stop------------------------------------------------------------Script 15.22 Options with No Values #!/bin/ksh#  Script: optNoVal.scr#  Demonstrate options with no valueswhile getopts xy variabledo    case $variable in      x) print "processing x option here" ;;      y) print "processing y option here" ;;    esacdoneExecution:$ optNoVal.scr                                # No options entered$ optNoVal.scr -x                             # Only one optionprocessing x option here$ optNoVal.scr -xy                            # Both options combinedprocessing x option hereprocessing y option here$ optNoVal.scr -x -y                          # Options separatedprocessing x option hereprocessing y option here$ optNoVal.scr -xy Hello                      # With argumentprocessing x option hereprocessing y option here$ optNoVal.scr -xz                            # Invalid optionprocessing x option hereoptNoVal.scr[3]: getopts: z bad option(s)     # getopts message------------------------------------------------------------Script 15.23 Detecting Invalid Options #!/bin/ksh#  Script: optNoVal2.scr#  Demonstrate options with no valueswhile getopts xy variable 2> /dev/nulldo    case $variable in      x)  print "processing x option here" ;;      y)  print "processing y option here" ;;      \?) print "Invalid option: Quitting" ; exit 1 ;;    esacdoneExecution:$ optNoVal2.scr -xy                  # Both options combinedprocessing x option hereprocessing y option here$ optNoVal2.scr -xw                  # Invalid optionprocessing x option hereInvalid option: Quitting------------------------------------------------------------Script 15.24 Options with Values#!/bin/ksh#  Script: optWithVal.scr#  Demonstrate option arguments with valueswhile getopts x:y: variable 2>/dev/null   # Both x & y have argumentsdo    case $variable in      x)  print "Processing x option here"          print "Value of the x option is $OPTARG" ;;      y)  print "Processing y option here"          print "Value of the y option is $OPTARG" ;;      \?) print "Invalid option: Quitting" ; exit 1 ;;    esacdoneprint Processing in body: Parameters contain $1 $2 $3 $4$ optWithVal.scr -x XXX -y YYY HelloOutput:Processing x option hereValue of the x option is XXXProcessing y option hereValue of the y option is YYYProcessing in body: Parameters contain -x XXX -y YYY------------------------------------------------------------Script 15.25 Shifting Options with OPTIND #!/bin/ksh#  Script: optWithVal2.scr#  Demonstrate use of OPTINDwhile getopts xy: variable 2>/dev/null           # y has valuedo    case $variable in      x)  print "Processing x option here" ;;      y)  print "Processing y option here"          print "Value of the y option is $OPTARG" ;;      \?) print "Invalid option: Quitting" ; exit 1 ;;    esacdoneprint Processing in body:print OPTIND contains: $OPTINDshift (( $OPTIND-1 ))print \$1 contains $1print \$2 contains $2$ optWithVal2.scr -xy YYY Hello Good-byeOutputProcessing x option hereProcessing y option hereValue of the y option is YYYProcessing in body:OPTIND contains: 3$1 contains Hello$2 contains Good-bye------------------------------------------------------------Script 15.26 Separate Filenames and Pathnames #!/bin/ksh #  Script: file.scr#  Uses dirname and basename to separate path from name#  $1 is filename with pathdir=$(dirname $1)base=$(basename $1)print "Complete pathname      :" $1print "Directory portion only :" $dirprint "Base portion only      :" $baseExecution:$ file.scr gilberg/scripts/file.scrComplete pathname      : gilberg/scripts/file.scrDirectory portion only : gilberg/scriptsBase portion only      : file.scr$ file.scr file.scrComplete pathname      : file.scrDirectory portion only : .Base portion only      : file.scr------------------------------------------------------------Script 15.27 Rename File Family #!/bin/ksh #  Script: renameFiles.scr#  Renames a file family by changing only the extensions.#  $1 is from file type; $2 is to file typeif [[ $# != 2 ]]   then      print "Requires two file type arguments"      print "Usage: $0 from_type to_type"      exit 1fifor name in *.$1do   first=$(basename $name $1)   mv $name ${first}$2doneInput:$ ls rename?.*rename1.ren  rename2.ren  rename3.ren  rename4.ren  rename5.renExecution$ renameFiles.scr ren zzzOutput:$ ls rename?.*rename1.zzz  rename2.zzz  rename3.zzz  rename4.zzz  rename5.zzz------------------------------------------------------------Script 15.28 Rename File Family #!/bin/ksh#  Script: renameFiles.scr#  Renames a file family by changing only the extensions.#  $1 is from file type; $2 is to file typeif(( $# != 2 ))then   print "Requires two file type arguments"   print "Usage: $0 from_type to_type"   exit 1fifor name in *.$1do   first=${name%.*}   mv $name ${first}.$2doneInput:$ ls rename?.*rename1.ren  rename2.ren  rename3.ren Execution$ renameFiles.scr ren zzzOutput:$ ls rename?.*rename1.zzz  rename2.zzz  rename3.zzz ------------------------------------------------------------Script 15.29 Copy File Script #!/bin/ksh # This script copies the contents of the first file ($1) to# the file specified in the second argument ($2).# Open the filesexec 0< $1exec 1> $2# Read and copy in loopwhile read linedo   print $linedone$ openCopy.scr TheRavenV1 TheRavenV1.bakTheRavenV1.bakOnce upon a midnight dreary, while I pondered, weak and weary,Over many a quaint and curious volume of forgotten loreWhile I nodded, nearly napping, suddenly there came a tapping,As of someone gently rapping, rapping at my chamber door."'Tis some visitor," I muttered, "tapping at my chamber doorOnly this and nothing more."------------------------------------------------------------Script 15.30 Split Bookstore Files#!/bin/ksh#  Script: splitFile.scr#  Split bookstore file by departments into four files#  The files are passed as arguments# Open filesexec 0<$1                       # Input fileexec 3>$2                       # Clothingexec 4>$3                       # Computersexec 5>$4                       # Suppliesexec 6>$5                       # Textswhile read linedo   print $line | egrep 'clothing'   1>& 3   print $line | egrep 'computers' 1>& 4   print $line | egrep 'supplies'  1>& 5   print $line | egrep 'textbooks' 1>& 6done# Close filesexec 0<&-exec 3>&-exec 4>&-exec 5>&-exec 6>&-print File processing complete.$ splitFile.scr bookstore.dat clot.dat comp.dat supp.dat text.datOutput:File processing complete.$ cat clot.dat1 clothing 31412 clothing 32523 clothing 2845$ cat comp.dat1 computers 91612 computers 123213 computers 10262$ cat supp.dat1 supplies 25632 supplies 22423 supplies 1805$ cat text.dat1 textbooks 213122 textbooks 154623 textbooks 20754------------------------------------------------------------Script 15.31 Child Shells: Temporary Environmental Changes #!/bin/ksh#  Script: childScript.scr#  Modify environment by changing pwdprint "Current directory was:    " $(pwd)cd ../print "Current directory is now: " $(pwd)Execution:$ pwd                                  # Before executing script/mnt/diska/staff/gilberg/unix14Korn$ childScript.scrCurrent directory was:     /mnt/diska/staff/gilberg/unix14KornCurrent directory is now:  /mnt/diska/staff/gilberg$ pwd                                  # After executing script/mnt/diska/staff/gilberg/unix14Korn------------------------------------------------------------Script 15.32 Child Shells: Permanent Environmental Changes $ pwd                                  # Before executing script/mnt/diska/staff/gilberg/unix14Korn$ . childScript.scrCurrent directory was:     /mnt/diska/staff/gilberg/unix14KornCurrent directory is now:  /mnt/diska/staff/gilberg$ pwd                                  # After executing script/mnt/diska/staff/gilberg------------------------------------------------------------Script 15.33 Calculate Script File#!/bin/ksh#NAME:         calc.scr#TASK:         Adds, subtracts, multiplies, and divides integers#AUTHOR:#DATE WRITTEN:#SYNOPSIS:     calculate option num1 num2#                  options: -a: add      -s: subtract#                           -m: multiply -q: quotient  -r: remainder#DESCRIPTION:  Adds, subtracts, multiplies or divides two integers#              based on argument 1.#EXIT VALUE#              0     if successfully completed#              1     if wrong number of arguments#              2     if wrong option# ======================================================# Load Korn shell user functions (contains numeric()). functions.scrif (( $# != 3 ))then   print "Exactly one option and two integers needed"   print "Usage: $0 -option integer integer"   exit 1figetopts asmqr opt 2> /dev/null        # System messages to trashcase $opt in     a) opr=+                    ;;     s) opr=-                    ;;     m) opr=\*                   ;;     q) opr=/                    ;;     r) opr=%                    ;;    \?) print "Invalid option"   ;        print "Usage: $0 -{asmqr} integer integer" ;        exit 2                   ;;esacshift# Use numeric() to validate $1 and $2valid $1valid $2((res = $1 $opr $2 ))print "$1 $opr $2 is $res"exit 0Execution:$ calc.scr -a a 3a is not numeric$ calc.scr -a 2 bb is not numeric$ calc.scr -a 2 32 + 3 is 5$ calc.scr -s 2 32 - 3 is -1$ calc.scr -m 2 32 * 3 is 6$ calc.scr -q 7 37 / 3 is 2$ calc.scr -r 7 37 % 3 is 1$ calc.scr -r 7Exactly one option and two integers neededUsage: calc.scr -option integer integer$ calc.scr -x 7 3Invalid optionUsage: calc.scr -{asmqr} integer integer------------------------------------------------------------Script 15.34 Reverse a String Script File#!/bin/ksh#NAME:        strrev.scr#TASK:        Reverse a string received as an argument.#AUTHOR#DATE WRITTEN:#SYNOPSIS:    strrev.str string#          or strrev.str "aa bbb cccc"#DESCRIPTION: Reverses a string using a loop. If string contains #   white space, it must be enclosed in quotes.#EXIT VALUE#             0     if successfully completed#             1     if wrong number of arguments# ======================================================if (( $# != 1 ))   then      print "This script requires one argument."      print "Usage: $0 string"      exit 1fiorg=$1rev=""len=${#1} while (( $len > 0 ))do   left=$(expr "$org" : '\(.\).*')   org=$(expr  "$org" : '.\(.*\)')   rev=$left$rev   (( len = len - 1 ))doneprint $revexit $0Execution:$ strrev.scrThis script requires one argument.Usage: strrev.scr string$ strrev.scr stringgnirts$ strrev.scr strings are very usefulThis script requires one argument.Usage: strrev.scr string$ strrev.scr 'strings are very useful'lufesu yrev era sgnirts------------------------------------------------------------Script 15.35 Add Column Script #!/bin/ksh #NAME:         addCol.scr#TASK:         Add the values in a specific column in a file#AUTHOR:#DATE WRITTEN:#SYNOPSIS:     addCol.scr file column_num#DESCRIPTION:  Uses awk to determine column.#              File must be in columns separated by whitespace#                1       2       3#               11      22      33#              111     222     333#EXIT VALUE#              0     if successfully completed#              1     if wrong number of arguments#              2     if the second argument is not numeric## ======================================================# Validate Numeric Functionnumeric( ){ # Test parameter 1 by adding. # If error, display error and quit. # All output to trash. let x=$1+1 1>/dev/null 2>&1  if (( $? != 0 ))              # if exit status is false then    print $1 is not numeric    exit 1                     # exit command kills script fi return} #End of Function# Script bodyif (( $# != 2 ))then      print "Exactly two arguments required"      print "Usage: $0 file_name column_number"      exit 1fi#Test for numeric column numbernumeric $2 filename=$1awk '{total += $colNum} END {print total}' colNum=$2 $filenameexit 0Input File: add.dat              1       2       3             11      22      33            111     222     333Execution:$ addCol.scr                             # No argumentsExactly two arguments requiredUsage: addCol.scr file_name column_number$ addCol.scr 1 add.dat                   # Arguments reversedadd.dat is not numericUsage: addCol.scr file_name column_number$ addCol.scr add.dat 1123$ addCol.scr add.dat 3369