Sessions forUNIX and Shell ProgrammingA TextbookBehrouz A. Forouzan and Richard F. GilbergBrooks/Cole Publishing( ISBN 0 534-95159-7)COPYRIGHT (c) 2003 the Wadsworth Group. Brooks/Cole is an imprint of the Wadsworth Group, a division of Thomson Learning, Inc. Thomson Learning(tm) is a trademark used herein under license.============================================================Chapter 18------------------------------------------------------------Script 18.1 Compress String Argument #!/bin/csh #  Script: strDltSpaces.scr#  This script used echo to delete extra spaces in a string.#  $1 is text stringset line = "$argv"echo $line% strDltSpaces.scr "Too   many   spaces     here."Output:Too many spaces here.------------------------------------------------------------Script 18.2 Compress File#!/bin/csh #  Script: strComprFile.scr#  Compress all lines in a file#  $argv[1] is file IDset line = $<while ( "$line"  != "" )   echo $line   set line = $<end% strComprFile.scr <spacy.dat% cat spacy.datToo    many      spaces in   this text.Way  too     many spaces.Our  compress        script will    delete the extra spaces.Output:Too many spaces in this text.Way too many spaces.Our compress script will delete the extra spaces.------------------------------------------------------------Script 18.3 Using Text in the Script #!/bin/csh#  Script: hereDoc.scr#  This script uses a message contained in the document itself#  To send a meeting notice to all project members.set list = `cat hereDocTeam.mail`foreach i ($list)     mail $i << MSG     The next project meeting is scheduled for next Friday.     LOCATION: Conf Room 12     TIME:     9am     AGENDA:  Please be prepared to discuss project schedule.               We have been asked to complete 3 months early.     AnneMSGecho mail sent to $iend% hereDoc.scr------------------------------------------------------------Script 18.4 Demonstrate Interrupt Handling #!/bin/csh/ -f#  Script: onintr.scr#  This script demonstrates interrupt handling in the C shellecho Test interrupt trap commands.set count = 0while ($count < 10000)   onintr catch         # set interrupt catch   @ count++   continue             # Interrupt handler follows   catch:   echo "Count is: $count\nCannot interrupt at this time"end% onintr.scrOutput:Test interrupt trap commands.Count is: 1715Cannot interrupt at this timeCount is: 7337Cannot interrupt at this time------------------------------------------------------------Script 18.5 Demonstrate sleep Command #!/bin/csh#  Script: sleep.scr#  Monitors who is logged in and sends call me message#  Check every minute to see if $1 is logged inwho | grep "$argv[1]" >/dev/nullset st = $statuswhile ($st !=0)   sleep 60   who | grep "$argv[1]" >/dev/null   # Run in background   set st = $statusend#  User is now logged inwrite $argv[1] << MSG   Urgent we talk.   Please call me A.S.A.P!   GilbergMSG$ sleep.scr forouzan&                 # Running in the background------------------------------------------------------------Script 18.6 Demonstrate String Parameters #!/bin/csh #  Script: strArguments.scr#  Demonstrate how string argument format affects readecho All Arguments: $argvecho Parm1 is: $argv[1]echo Parm2 is: $argv[2]echo Parm3 is: $argv[3]echo Parm4 is: $argv[4]Execution:% strArguments.str Now is the timeAll Arguments: Now is the timeParm1 is: NowParm2 is: isParm3 is: theParm4 is: time% strArguments.str "Now is the time"All Arguments: Now is the timeParm1 is: Now is the timeSubscript out of range------------------------------------------------------------Script 18.7 Prompt Script #!/bin/csh #  Script: prompt.scr#  Demonstrate a typical user promptecho "Enter file name: \c"set fileName = $<echo You entered $fileName% prompt.scrOutput:Enter file name: payroll.datYou entered payroll.dat------------------------------------------------------------Script 18.8 Demonstrate Pathname Modifiers #!/bin/csh#  Script: pathMod.scr#  Demonstrates four variable modifier options.set name = "/usr/staff/gilberg/pgm1.c++"echo "Complete path:          $name"echo "Path without extension: $name:r"echo "Only the extension:     $name:e"echo "Only the basename:      $name:t"echo "Only the directory:     $name:h"pathMod.scrOutput:Complete path:          /usr/staff/gilberg/pgm1.c++Path without extension: /usr/staff/gilberg/pgm1Only the extension:     c++Only the basename:      pgm1.c++Only the directory:     /usr/staff/gilberg------------------------------------------------------------Script 18.9 Child Shells: Temporary Environmental Changes#!/bin/csh#  Script: childScript.scr#  Modify environment by changing pwdecho "Current directory was:    " `pwd`cd ../echo "Current directory is now: " `pwd`Execution:% pwd                                  # Before executing script/mnt/diska/staff/gilberg/unix20csh% childScript.scrCurrent directory was:     /mnt/diska/staff/gilberg/unix20cshCurrent directory is now:  /mnt/diska/staff/gilberg% pwd                                  # After executing script/mnt/diska/staff/gilberg/unix20csh------------------------------------------------------------Script 18.10 Child Shells: Permanent Environmental Changes % pwd                                  # Before executing script/mnt/diska/staff/gilberg/unix20csh% source childScript.scrCurrent directory was:     /mnt/diska/staff/gilberg/unix20cshCurrent directory is now:  /mnt/diska/staff/gilberg% pwd                                  # After executing script/mnt/diska/staff/gilberg------------------------------------------------------------Script 18.11 Creating an Array: Assignment #!/bin/csh#  Script: aryAsgn.scr#  Demonstrate creating an array by assignmentset ary = (one two three four five)echo "The whole array:        $ary"echo "The number of elements: $#ary"echo "The first element:      $ary[1]"echo "The last element:       $ary[$#ary]"% aryAsgn.scrOutputThe whole array:        one two three four fiveThe number of elements: 5The first element:      oneThe last element:       five------------------------------------------------------------Script 18.12 Creating an Array: Command Substitution#!/bin/csh#  Script: aryCmdSub.scr#  Demonstrate creating an array by command substitutionset ary = `cat ary.dat`echo "The whole array:        $ary"echo "The number of elements: $#ary"echo "The first element:      $ary[1]"echo "The last element:       $ary[$#ary]"% aryCmdSub.scrInput:onetwothree four fiveOutputThe whole array:        one two three four fiveThe number of elements: 5The first element:      oneThe last element:       five------------------------------------------------------------Script 18.13 Creating an Array: String Conversion #!/bin/csh#  Script: aryString.scr#  Demonstrate creating an array by string conversion#  String is in argv[1]set ary = ($argv[1])echo "The whole array:        $ary"echo "The number of elements: $#ary"echo "The first element:      $ary[1]"echo "The last element:       $ary[$#ary]"% aryString.scr "one two three four five"OutputThe whole array:        one two three four fiveThe number of elements: 5The first element:      oneThe last element:       five------------------------------------------------------------Script 18.14 Count Words in a File #!/bin/csh#  Script: aryString.scr#  Demonstrate creating an array through a string#  String is in argv[1]set totalWords = 0set line = $<while ("$line" != "")   set words = ($line)   @ totalWords += $#words   set line = $<endecho Total Words: $totalWords% aryParse.scr <TheRavenV1Output:Total Words: 56------------------------------------------------------------Script 18.15 Find Files#!/bin/csh -f# NAME:          find.scr# TASK:          Find the pathname of a file# AUTHOR:# DATE WRITTEN:# SYNOPSIS:      find.scr searchpath file or find.scr file# DESCRIPTION:   It finds the pathname of a file#                argv[1] is file name#             or argv[1] is path and argv[2] is file name# Exit value#   0   if successful#   1   if wrong number of arguments#   2   if the search-path is not a directory#   3   if the file is not foundset noglobif ( $#argv < 1 || $#argv > 2 ) then        echo "$0 needs one or two arguments"        exit 1endifif ( $#argv == 2 ) then       set srchPath = $argv[1]       shift       if ( ! -d $srchPath ) then          echo "$srchPath is not a directory"          exit 2       endifelse       set srchPath = $HOMEendifif ( ! -d $srchPath ) then     echo "$srchPath is not a directory"     exit 2endifset temp = ./t.tempfind $srchPath -name $argv[1] -print | tee $tempif (-z $temp) then              # Test for empty output file     echo "Cannot find file $argv[1]"     exit 3endifrm $temp                        # Delete temporary fileexit 0Execution:% find.scrfind.scr needs one or two arguments% find.scr x yx is not a directory% find.scr file5/mnt/diska/staff/gilberg/unix13bourne/file5/mnt/diska/staff/gilberg/unix14bourne/file5/mnt/diska/staff/gilberg/unix20csh/file5/mnt/diska/staff/gilberg/unix3files/delRecDir.bak/DirB/file5/mnt/diska/staff/gilberg/unix17korn/file5% find.scr . file5./file5------------------------------------------------------------Script 18.16 Large System Design: Main Script#!/bin/csh # NAME:           acctMain.scr# TASK:           Runs different accounting programs# AUTHOR:# DATE WRITTEN:# SYNOPSIS:       acctMain.scr# DESCRIPTION:    Uses a menu# Exit value#    0   if successfulclearset menu = ./acctMenu.scrset acc  = ./while (1)   cat $menu   echo -n "Choose an option: "   set answ = $<   switch ($answ)       case [aA] :                    ${acc}/acctAcct.scr                    breaksw       case [gG] :                    ${acc}/acctGL.scr                    breaksw       case [pP] :                    ${acc}/acctPay.scr                    breaksw       case [qQ] :                    echo "\n\nThank you for using Accounting"                    exit 0                    breaksw       default   :                    echo " $answ is invalid. Enter <AGPQ>"                    breaksw    endswend% acctMain.scrOutput:********* MENU ***********                    ****  A. Accounting     ****  G. General Ledger ****  P. Payroll        ****  Q. Quit           ****                    **************************Choose an option: x x is invalid. Enter <AGPQ>********* MENU ***********                    ****  A. Accounting     ****  G. General Ledger ****  P. Payroll        ****  Q. Quit           ****                    **************************Choose an option: gThis is the general ledger program********* MENU ***********                    ****  A. Accounting     ****  G. General Ledger ****  P. Payroll        ****  Q. Quit           ****                    **************************Choose an option: qThank you for using Accounting------------------------------------------------------------Script 18.17 Large System Design: Menu ********* MENU ***********                    ****  A. Accounting     ****  G. General Ledger ****  P. Payroll        ****  Q. Quit           ****                    **************************------------------------------------------------------------Script 18.18 Large System Design: Accounting #!/bin/csh #  Script: acctAcct.scr#  This is a stub for the accounting program.echo "\nThis is the basic accounting program"------------------------------------------------------------Script 18.19 Large System Design: General Ledger #!/bin/csh #  Script: acctGL.scr#  This is a stub for general ledger.echo "\nThis is the general ledger program"------------------------------------------------------------Script 18.20 Large System Design: Payroll #!/bin/csh #  Script: acctPay.scr#  This is a stub for payroll.echo "\nThis is the payroll program"------------------------------------------------------------Script 18.21 Remove Duplicates # NAME:         rmDups.scr# TASK:         Removes duplicate words from a list/file# AUTHOR:# DATE WRITTEN:# SYNOPSIS:     rmDups.scr input_list output_list# DESCRIPTION:  Uses a flag to remove duplicates#                 argv[1] is input list#                 argv[2] is output list# Exit value#    0   if successful#    1   if wrong number of argumentsif ( $#argv != 2 ) then        echo "$0 requires two arguments"        echo "$0 infile outfile"        exit 1endifset newlistset oldlist = `cat $argv[1]`foreach element ($oldlist)   set flag = "on"   # Test each word in newlist to see if newElement is dupe   foreach newElement ($newlist)      if ($newElement == $element ) then          set flag = "off"          break                      # Found dupe. Get out.      endif   end # foreach newElement   if ($flag == "on") then       set newlist = ($newlist $element)   endifend # foreach element# Newlist complete. Write it to argv[2]echo $newlist > $argv[2]exit 0% rmDups.scr rmDups.dat outfileInput:% cat rmDups.datonetwotwothreethreethreeone fourOutput:% cat outfileone two three four